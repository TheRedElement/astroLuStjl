
"""
    - module to define function for parsing strings into several julia-native datatypes

    Constants
    ---------

    Functions
    ---------
        - `parse2compoundperiod()`

    Macros
    ------
        - `@p_str`

    Structs
    -------

    Dependencies
    ------------
        - `Dates`

    Comments
    --------

    Examples
    --------
        - see [StringParsing_demo.jl](../../demos/InOutput/StringParsing_demo.jl)

"""
module StringParsing


#%%imports
using Dates

#%%exports
export parse2compoundperiod
export @p_str
#intradependencies


#%%string macros
macro p_str(s) s end    #macro to define p"..." strings #essentially raw string (escapes etc. do not matter)

#%%CompoundPeriod parsing
"""
    - function to parse a string generated from a `Dates.CompoundPeriod` back into a `Dates.CompoundPeriod`

    Parameters
    ----------
        - `s_cp`
            - `String`
            - the string to be parsed
            - has to be generated by `Dates.CompoundPeriod`

    Raises
    ------

    Returns
    -------
        - `cp`
            - `Dates.CompoundPeriod`
            - `s_cp` but converted to a `Dates.CompoundPeriod`

    Comments
    --------
"""
function parse2compoundperiod(
    s_cp::String,
    )::Dates.CompoundPeriod

    r = [
        p"(?<days>\d+(?= day))",
        p"(?<hours>\d+(?= hour))",
        p"(?<minutes>\d+(?= minute))",
        p"(?<seconds>\d+(?= second))",
        p"(?<milliseconds>\d+(?= millisecond))",
    ]
    em = eachmatch(Regex(join(r, "|")), s_cp)
    
    d  = parse.(Float32,(filter(x -> ~isnothing(x), [m[:days] for m in em])))
    h  = parse.(Float32,(filter(x -> ~isnothing(x), [m[:hours] for m in em])))
    m  = parse.(Float32,(filter(x -> ~isnothing(x), [m[:minutes] for m in em])))
    s  = parse.(Float32,(filter(x -> ~isnothing(x), [m[:seconds] for m in em])))
    ms = parse.(Float32,(filter(x -> ~isnothing(x), [m[:milliseconds] for m in em])))
    
    components = [d, h, m, s, ms]
    units = [Day, Hour, Minute, Second, Millisecond]
    components = map(x -> length(x[1]) == 0 ? x[2](0) : x[2](x[1][1]), zip(components,units))
    cp = Dates.CompoundPeriod(components...)

    return cp

end

end #module